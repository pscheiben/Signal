% Signal class made for the module Digital Signal Processing labs and for Honours Project Simulations by Peter Scheibenhoffer.
% Glasgow Caledonian University EEE course 4th year.
% Start Date: 04/10/2023
% Last modification: 05/10/2023


% Signal class has properties and functions according to the lab exercises of DSP and simulation requirements for the Honours Project.
% Properties:
% Amplitude         Amplitude of the signal refer to Unity
% Type              Sinusoid or White Noise
% Frequency         Frequency of the signal in Hertz
% Phase             Phase shift in Degrees
% Start_Time        Time in seconds
% Duration          Signal length in seconds
% Sample_per_Cycle  Number of sample in one period intervall
% Data_Vector       Generated values according to the properties. It can be
% generated by the "generate" function
%


classdef Signal
    properties
        Amplitude double
        Type string
        Frequency double 
        Phase double
        Start_Time double
        Duration double
        End_Time double
        Sample_per_Cycle double
        PhaseShiftperUnit double
        ShiftperUnit double
        Time_Vector 
        Data_Vector 

    end

    methods
        function sig = Signal(Amplitude,Type,Frequency,Phase,Start_Time,Duration,Sample_per_Cycle)
            %constructor function
            if (nargin == 7)
            sig.Amplitude = Amplitude;
            sig.Type = Type;
            sig.Frequency = Frequency;
            sig.Phase = Phase;
            sig.Start_Time = Start_Time;
            sig.Duration = Duration;
            sig.End_Time = sig.Start_Time + sig.Duration;
            sig.Sample_per_Cycle = Sample_per_Cycle;
            sig.PhaseShiftperUnit = 360/sig.Sample_per_Cycle;
            % This calculates how many units of shift required for a Phase according to Sample_per_Cycle 
            sig.ShiftperUnit = round(sig.Phase / sig.PhaseShiftperUnit);
            end

        end

        function Y = generate_time_vector(sig)                   %Time_Vector generator
            Sampling_Frequency = sig.Frequency * sig.Sample_per_Cycle;
            Y = [sig.Start_Time:(1/Sampling_Frequency):sig.End_Time];
        end

        function Y = generate_data_vector(sig)                   %Data_Vector generator
            Phase_Rad = sig.Phase*2*pi/360;
            if (sig.Type == "sinSignal")
                Y = sig.Amplitude*cos(2*pi*sig.Frequency*sig.Time_Vector+Phase_Rad);
            else
                Y = sig.Amplitude*rand(size(sig.Time_Vector));

            end
        end
        % shiftwhitenoise function shift the input according to the Phase, Frequency and a number Sample_per_Cycle
        function Y = shiftwhitenoise(sig)
            addata = sig.Amplitude*rand(size(sig.ShiftperUnit));
            if (sig.Phase>=0)
                Y = [addata,sig.Data_Vector(1:end-size(sig.ShiftperUnit))];
            else
                Y = [sig.Data_Vector(1:end-size(sig.ShiftperUnit)),addata]
            end

        end
        
        % signalAdd function add together two function and generate the
        % signal object for the result signal
        function sumsig = signalAdd(sumsig,sig1,sig2)
            sumsig.Amplitude = (sig1.Amplitude + sig2.Amplitude);
            sumsig.Type = "sinSignal";
            sumsig.Frequency = 3000;
            sumsig.Phase = 0;
            sumsig.Start_Time = min(sig1.Start_Time, sig2.Start_Time);
            sumsig.End_Time = max(sig1.End_Time, sig2.End_Time);
            sumsig.Duration = sumsig.End_Time-sumsig.Start_Time;
            sumsig.Sample_per_Cycle = sig1.Sample_per_Cycle;
            sumsig.PhaseShiftperUnit = 360/sumsig.Sample_per_Cycle;
            % This calculates how many units of shift required for a Phase according to Sample_per_Cycle 
            sumsig.ShiftperUnit = round(sumsig.Phase / sumsig.PhaseShiftperUnit);
            sumsig.Time_Vector = sig1.Time_Vector;
            sumsig.Data_Vector = (sig1.Data_Vector + sig2.Data_Vector);
        end

        % plotaround function plot the signal of sig around a reference point of Ref_Point with
        % a width of Range of cycles.
        % The function calculates the necessarry data from the Signal class
        % attributes

        function plotaround(sig,Ref_Point,Cycle_Amount)
            if (Ref_Point<sig.Start_Time || Ref_Point>(sig.Start_Time+sig.Duration))
                %Checking, that the Reference point is in the Signal
                error = "Reference point outside of the Signal's Scope";
                disp(error)
            else
                zero_idx = abs(sig.Start_Time)*sig.Frequency*sig.Sample_per_Cycle+1 ;
                cycle_idx = Cycle_Amount*sig.Sample_per_Cycle;
                %Checking that the Cycle of interest is still in the range
                %of the signal_time vector
                if ((zero_idx - round(cycle_idx/2) < 0) || ((size(sig.Time_Vector,2)-zero_idx-round(cycle_idx/2))<0))
                    error = "Cycle range is too big for the reference point";
                    disp(error)
                else
                    %calculating the index vector accourding to the
                    %reference point and the cycle amount. Selecting the
                    %interested part from the time and data vector
                    index_of_interest = round(zero_idx-cycle_idx/2):round(zero_idx+cycle_idx/2);
                    interval_of_interest = sig.Time_Vector(index_of_interest);
                    sig_of_interest = sig.Data_Vector(index_of_interest);
                    plot(interval_of_interest,sig_of_interest)

                end
            end

        end

    end
end